{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,KAAK,wGAAwG;AAC7G;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA,SAAS;AACT,oEAAoE;AACpE;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,QAAQ;AACR,mFAAmF;AACnF;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,UAAU,MAAM,SAAS;AAC3C,wCAAwC,WAAW;AACnD,sCAAsC,UAAU;AAChD;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,4CAA4C;AAC5C,2CAA2C,IAAI,YAAY,cAAc,qBAAqB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAiC,aAAa;AACnE;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA,mBAAmB,KAAK,MAAM,OAAO;AACrC,wCAAwC,MAAM;AAC9C,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA,MAAM;AACN,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yDAAyD;AACzD;AACA;AACA,8GAA8G;AAC9G;AACA;AACA;AACA;AACA,IAAI,YAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA,KAAK;AACL,GAAG,EAAE;AACL;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,qDAAqD;AACrD;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,6EAA6E;AAC7E,4EAA4E;AAC5E;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,mDAAmD;AACnD;AACA,SAAS;AACT;AACA,6EAA6E;AAC7E;AACA;AACA,uCAAuC;AACvC;AACA,oDAAoD;AACpD;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,oDAAoD;AACpD;AACA;AACA,uDAAuD;AACvD,SAAS;AACT,yDAAyD;AACzD,SAAS;AACT,qDAAqD;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8EAA8E;AAC9E,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,sEAAsE;AACtE,uEAAuE;AACvE;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,gCAAgC,aAAa;AAC7C,MAAM;AACN;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,8BAA8B,cAAc;AAC5C,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,6CAA6C;AAC7C;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,6CAA6C;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA,mEAAmE;AACnE;AACA,gEAAgE;AAChE;AACA,8BAA8B,cAAc;AAC5C,gCAAgC,aAAa;AAC7C,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,mEAAmE;AACnE;AACA;AACA;AACA,mEAAmE;AACnE,GAAG;AACH;AACA;AACA;AACA,iEAAiE;AACjE,iEAAiE;AACjE;AACA;AACA;AACA,kBAAkB,mBAAmB,6BAA6B;AAClE;AACA,kEAAkE;AAClE;AACA;AACA,kEAAkE;AAClE;AACA;AACA,kEAAkE;AAClE;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA,OAAO;AACP,oEAAoE;AACpE,qFAAqF;AACrF,iDAAiD,OAAO;AACxD;AACA,4EAA4E;AAC5E;AACA,MAAM;AACN,4DAA4D;AAC5D;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,MAAM;AACN;AACA;AACA,oDAAoD;AACpD;AACA,KAAK;AACL,0DAA0D;AAC1D,GAAG;AACH;AACA;AACA,mFAAmF;AACnF;AACA,OAAO;AACP;AACA;AACA,iDAAiD,OAAO;AACxD;AACA,+DAA+D;AAC/D;AACA,IAAI;AACJ,gEAAgE;AAChE;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA,qCAAqC,aAAa;AAClD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;;;;;;;;;;ACvCA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,kBAAkB,IAAI;AACtB,OAAO;AACP;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,mDAAmD;AACnD,qDAAqD;AACrD,yDAAyD;AACzD,yDAAyD;AACzD,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCtDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA;AACA;AACA,iBAAiB,mBAAO,CAAC,wDAAsB;AAC/C,gBAAgB,mBAAO,CAAC,4CAAgB;AACxC,gBAAgB,mBAAO,CAAC,8CAAiB;AACzC,eAAe,mBAAO,CAAC,gDAAkB;AACzC,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C,iBAAiB,mBAAO,CAAC,4CAAgB;AACzC,iBAAiB,mBAAO,CAAC,8CAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://dist/./js/modules/calculator.js","webpack://dist/./js/modules/card.js","webpack://dist/./js/modules/modal.js","webpack://dist/./js/modules/server.js","webpack://dist/./js/modules/slider.js","webpack://dist/./js/modules/tabs.js","webpack://dist/./js/modules/timer.js","webpack://dist/webpack/bootstrap","webpack://dist/./js/script.js"],"sourcesContent":["// CALCULATOR\r\n\r\nconst calculator = () => {\r\n    \r\nconst result = document.querySelector(\".calculating__result span\"); // поле вывода результата\r\n\r\n let sex;                                                          \r\n let height;                               \r\n let weight;                                          \r\n let age;\r\n let ratio;                               \r\n\r\n if (localStorage.getItem(\"sex\")) {                    // если в localStorage есть данные используем их, если нет задаем дефолтное значение\r\n   sex = localStorage.getItem(\"sex\")\r\n } else {\r\n   sex = \"female\";\r\n   localStorage.setItem(\"sex\", \"female\")\r\n }\r\n\r\n if (localStorage.getItem(\"ratio\")) {                    // если в localStorage есть данные используем их, если нет задаем дефолтное значение\r\n   ratio = localStorage.getItem(\"ratio\")\r\n } else {\r\n   ratio = \"1.375\";\r\n   localStorage.setItem(\"ratio\", \"1.375\")\r\n }\r\n\r\n const initLocalSettings = (selector) => {                    // функция для localStorage\r\n    const elements = document.querySelectorAll(selector);\r\n    elements.forEach((element) => {\r\n     element.classList.remove(\"calculating__choose-item_active\")\r\n     if (element.getAttribute(\"id\") === localStorage.getItem(\"sex\")) {\r\n        element.classList.add(\"calculating__choose-item_active\")\r\n     }\r\n     if (element.getAttribute(\"data-ratio\") === localStorage.getItem(\"ratio\")) {\r\n       element.classList.add(\"calculating__choose-item_active\")\r\n     }\r\n    })\r\n }\r\n initLocalSettings(\"#gender div\")\r\n initLocalSettings(\".calculating__choose_big div\")\r\n\r\n const calcTotal = () => {                                       \r\n   if (!sex || !height || !weight || !age ||!ratio) {             // при отсутсивии данных выдаем ошибку\r\n       result.textContent = \"___\"\r\n       return                                                     // досрочно прерываем функцию\r\n   } \r\n\r\n   if (sex === \"female\") {                                         // если пол женский\r\n      result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio)     // здесь берем формулу расчета каллорий и умножаем на уровень активности (см дата атрибуты в верстке у полей активности)\r\n   } else {                                                                                                  // округляем все до целого числа\r\n     result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio)      // здесь тоже самое, что для женщин только для мужчин уже новая формула\r\n   }\r\n }\r\n calcTotal()\r\n\r\n const getStaticInformation = (selector) => {              // как аргумент передаем родителя и класс активности\r\n    const elements = document.querySelectorAll(selector)         // получаем все дивы внутри родителя\r\n    \r\n\r\n    elements.forEach((element) => {\r\n      element.addEventListener(\"click\", (evt) => {\r\n       if (evt.target.getAttribute(\"data-ratio\")) {                            // если у элемента есть дата атрибут\r\n          ratio = evt.target.getAttribute(\"data-ratio\")        // переменная ratio будет = значению, написанному в дата атрибуте в верстке\r\n          localStorage.setItem(\"ratio\", evt.target.getAttribute(\"data-ratio\"))  // записываем значение в localStorage\r\n       } else {\r\n         sex = evt.target.getAttribute(\"id\");                       // обращаемся к полям у которых нет дата атрибута, а есть id\r\n         localStorage.setItem(\"sex\", evt.target.getAttribute(\"id\"))  // записываем значение в localStorage\r\n       }\r\n      \r\n   \r\n       elements.forEach((item) => {                           // удаляем класс активности у всех элементов\r\n         item.classList.remove(\"calculating__choose-item_active\");\r\n       })\r\n       evt.target.classList.add(\"calculating__choose-item_active\");                // добавляем класс активности туда куда кликнули\r\n       calcTotal()                                    // каждый раз вызываем функцию пересчета\r\n     }) \r\n   })   \r\n }\r\n\r\n\r\n getStaticInformation(\"#gender div\")  // передаем как аргумент div внутри родителя\r\n getStaticInformation(\".calculating__choose_big div\")  // передаем сюда div внутри родителя\r\n // Вызываем функцию два раза, так как у нас два блока элементов: М\\Ж и блоки активности\r\n\r\n const getDynamycInformation = (id) => {\r\n    const input = document.querySelector(id);\r\n    input.addEventListener(\"input\", () => {\r\n       if (input.value.match(/\\D/g)) {                 // проверяем инпут на буквы и если вводятся не цифры, то красный бордер\r\n          input.style.border = \"1px solid red\"\r\n       } else {\r\n         input.style.border = \"none\"\r\n       }\r\n\r\n      switch(input.getAttribute(\"id\")) {             // проверяем на id инпуты, каждый раз когда будет что-то вводиться, то проверяется id и записывается соответствующее значение\r\n        case \"height\": \r\n           height = input.value;\r\n           break;\r\n        case \"weight\":\r\n           weight = input.value;\r\n           break;\r\n         case \"age\":\r\n           age = input.value;\r\n           break;\r\n        }\r\n        calcTotal()                              // каждый раз вызываем функцию пересчета\r\n    })\r\n  }\r\n getDynamycInformation(\"#height\")     // вызываем функцию с тремя разными id\r\n getDynamycInformation(\"#weight\")\r\n getDynamycInformation(\"#age\")\r\n}\r\nmodule.exports = calculator;","// CARDS\r\n// CLASSES FOR CARDS AND CARD CREATION (WITHOUT CLASSES LOOK FOR THE SERVER PART BELOW) \r\n\r\nconst cards = () => {\r\nclass MenuCard {\r\n    constructor (img, alt, title, text, price, parentSelector, ...classes) {\r\n      this.img = img;\r\n      this.alt = alt;\r\n      this.title = title;\r\n      this.text = text;\r\n      this.price = price;\r\n      this.classes = classes;\r\n      this.parent = document.querySelector(parentSelector);\r\n      this.currency = 75;\r\n      this.changeToRub();\r\n    }\r\n  \r\n    changeToRub() {\r\n      this.price = this.price * this.currency;\r\n    }\r\n  \r\n    render() {\r\n      const newElement = document.createElement(\"div\");\r\n      if(this.classes.length === 0) {\r\n        this.newElement = \"menu__item\";  // задаем дефолтный класс, если никаких классов в rest операторе нет\r\n        newElement.classList.add(this.newElement);\r\n      } else {\r\n        this.classes.forEach((item) => {\r\n          newElement.classList.add(item);\r\n        });\r\n      }\r\n       newElement.innerHTML = \r\n      `<img src=${this.img} alt=${this.alt}>\r\n      <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n      <div class=\"menu__item-descr\">${this.text}</div>\r\n      <div class=\"menu__item-divider\"></div>\r\n      <div class=\"menu__item-price\">\r\n          <div class=\"menu__item-cost\">Цена:</div>\r\n          <div class=\"menu__item-total\"><span>${this.price}</span> руб/день</div>\r\n      </div>`;\r\n    this.parent.append(newElement);\r\n    }\r\n  }\r\n\r\n  const getData = async (url) => {          // внутри функции будет асинхронный код, async и await всегда используются в паре, в данной строке получаем информацию\r\n    const result = await fetch(url);\r\n  \r\n    if (!result.ok)           {             // проверяем прошел ли запрос\r\n       throw new Error (`Could not fetch ${url}, status: ${result.status}`);                  // выкидываем ошибку\r\n    }              \r\n    return await result.json ()\r\n  }\r\n  \r\n  getData(\"http://localhost:3000/menu\")                            // запрос к серверу\r\n    .then(data => {\r\n      data.forEach(({img, altimg, title, descr, price}) => {       // деструктуризация объекта \r\n        new MenuCard(img, altimg, title, descr, price, \".menu .container\").render()   // создание карточек на основе шаблона в классах (один из вариантов создания карточек)\r\n      });\r\n    });\r\n\r\n  /*getData(\"http://localhost:3000/menu\")                       // СОЗДАНИЕ КАРТОЧЕК БЕЗ ШАБЛОНИЗАЦИИ ПО КЛАССАМ\r\n  .then(data => createCard(data));\r\n  \r\n  const createCard = (data) => {\r\n     data.forEach(({img, altimg, title, descr, price}) => {\r\n        const element = document.createElement(\"div\");\r\n        element.classList.add(\"menu__item\");\r\n        element.innerHTML = `\r\n        <img src=${img} alt=${altimg}>\r\n      <h3 class=\"menu__item-subtitle\">${title}</h3>\r\n      <div class=\"menu__item-descr\">${descr}</div>\r\n      <div class=\"menu__item-divider\"></div>\r\n      <div class=\"menu__item-price\">\r\n          <div class=\"menu__item-cost\">Цена:</div>\r\n          <div class=\"menu__item-total\"><span>${price}</span> руб/день</div>\r\n      </div>\r\n        `\r\n        document.querySelector(\".menu .container\").append(element);\r\n     })\r\n  }*/\r\n}\r\n\r\nmodule.exports = cards;\r\n\r\n ","// MODAL\r\n\r\nconst modal = () => {\r\nconst openModalButtons = document.querySelectorAll(\".btn_open_modal\");\r\nconst modal = document.querySelector(\".modal\");\r\nconst modalCloseButton = document.querySelector(\".modal__close\");\r\n\r\nconst modalEscPressHandler = (evt) => {\r\n  if (evt.key === \"Escape\") {\r\n    hideModalWindow();\r\n    evt.preventDefault();\r\n  }\r\n};\r\n\r\nconst windowClickHandler = (evt) => {\r\n  if (evt.target === modal) {\r\n    hideModalWindow();\r\n  }\r\n};\r\n\r\nconst openModalWindow = () => {\r\n  modal.classList.add(\"show\");\r\n  document.addEventListener(\"keydown\", modalEscPressHandler);\r\n  modal.addEventListener(\"click\", windowClickHandler);\r\n  modalCloseButton.addEventListener(\"click\", hideModalWindow);\r\n  document.body.style.overflow = \"hidden\";\r\n  clearInterval(modalTimerId);  // если модальное окно уже было открыто, то обнуляем setTimeout \r\n};\r\n\r\nconst hideModalWindow = () => {\r\n  modal.classList.remove(\"show\");\r\n  document.removeEventListener(\"keydown\", modalEscPressHandler);\r\n  modal.removeEventListener(\"click\", windowClickHandler);\r\n  modalCloseButton.removeEventListener(\"click\", hideModalWindow);\r\n  document.body.style.overflow = \"visible\";\r\n};\r\n\r\nopenModalButtons.forEach((item) => {\r\n  item.addEventListener(\"click\", openModalWindow);\r\n});\r\n\r\nconst modalTimerId = setTimeout(openModalWindow, 50000); // запускаем модалку через 5 секунд\r\n\r\nconst showModalByScroll = () => {\r\n  if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight){   // пользователь докрутил до конца страницы (сравниваем видимый контент на странице + сколько уже прокручено со всей высотой скролла)\r\n    openModalWindow(); \r\n    window.removeEventListener(\"scroll\", showModalByScroll);\r\n   }\r\n};\r\n// {once: true} это заставляет обработчик сработать один раз, но в данном случае не подходит\r\n// сдвинуть колд вправо tab\r\n// сдвинуть код влево shift+tab\r\nwindow.addEventListener(\"scroll\", showModalByScroll); \r\n\r\n  window.modal = {\r\n    hideModalWindow\r\n  }\r\n}\r\n\r\n\r\n\r\nmodule.exports = modal;","// SERVER GET/POST FETCH API JSON\r\n\r\nconst server = () => {\r\n  \r\n  /*axios.get(\"http://localhost:3000/menu\")                        // AXIOS служит для обращения к серверу (GEt\\POST) без создания дополнительных функций\r\n  .then(data => {\r\n    data.data.forEach(({img, altimg, title, descr, price}) => {       \r\n      new MenuCard(img, altimg, title, descr, price, \".menu .container\").render()   \r\n    });\r\n  });*/\r\n  \r\n  const forms = document.querySelectorAll(\"form\");\r\n    const  message = {                         // создаем объект с текстовыми сообщениями\r\n      loading: \"img/spinner.svg\",\r\n      success: \"Спасибо и до свидания\",\r\n      error: \"Ошибка\"\r\n    }\r\n                       \r\n    const postData = async (url, data) => {          // внутри функции будет асинхронный код, async и await всегда используются в паре\r\n      const result = await fetch(url, {              // здесь дожидаеся ответа await \r\n        method: \"POST\",                          // отправляем информацию\r\n          headers: {\r\n            \"Content-type\": \"application/json \"       //заголовки нужны для отправки JSON\r\n          },\r\n          body: data                                  // фукнцию postData можно испольоваться как универсальную с различными аргументами\r\n      });\r\n  \r\n      return await result.json()\r\n    }\r\n  \r\n    const bindPostData = (form) => {\r\n      const formSendingHandler = (evt) => {\r\n        evt.preventDefault();\r\n       \r\n        const statusMessage = document.createElement(\"img\");    // создаем новый элемент с текстовым сообщением и добавляем его на страницу\r\n        statusMessage.src = message.loading;\r\n        statusMessage.style.cssText = `  \r\n          margin: 0 auto;\r\n          display: block;         \r\n        `;                                                                   // CSS стили пропишем inline\r\n        form.insertAdjacentElement(\"afterEnd\", statusMessage);              // вставляем элемент после формы\r\n        \r\n        const formData = new FormData(form);   // собираем данные из формы, которые будем отправлять, как аргумент передается форма с которой собираем данные\r\n                                               // !!! в html всегда обязательно указывать артрибут name=\"name\" для интерактивных полей (input, textarea и т.д.) иначе FormData не найдет его !!!\r\n  \r\n        /*const object = {};                        \r\n          formData.forEach(function(value, key) {  // ДЛЯ JSON  перебираем formData и формируем новый объект, так как JSON не примет formData другим образом\r\n            object[key] = value;\r\n        })*/                                        // заменили на способ ниже\r\n  \r\n        const json = JSON.stringify(Object.fromEntries(formData.entries())); // превращаем formData в массив массивов, затем в классический объект и затем в json\r\n  \r\n        //  Object.entries(obj) преобразует объект в массив массивов [key, value]\r\n        //  Object.fromEntries(array); преобразует массив в объект\r\n  \r\n        /*fetch(\"server.php\", {                     // обращаемся к серверу, вынесли это в отдельную функцию PostData\r\n          method: \"POST\",                          // отправляем информацию\r\n          headers: {\r\n            \"Content-type\": \"application/json \"       //заголовки нужны для отправки JSON\r\n          },\r\n          body: json                             // сюда передаем json\r\n        })*/\r\n        postData(\"http://localhost:3000/requests\", json)  // ДЛЯ JSON подготтавливаем данные для сервера\r\n        .then(data => {                             // с сервера вернется какая-то информация\r\n          console.log(data);\r\n          showThanksModal(message.success);                                       \r\n          statusMessage.remove();                      // удаляем сообщение через 2 секунды\r\n        }).catch(() => {\r\n          showThanksModal(message.error);                // если внутри fetch promise попадает на ошибку (404, 502 и т.д.), то reject не будет и promise выполниться, ошибка сработает только при отсутствии интернета\r\n        }).finally(() => {\r\n          form.reset();                              // очистка формы, также можно взять инпуты и сделать их value === \"\";\r\n        })   \r\n      }\r\n      const hideModalWindow = window.modal.hideModalWindow;\r\n      form.addEventListener(\"submit\", formSendingHandler)\r\n      form.addEventListener(\"submit\", hideModalWindow)\r\n    }\r\n  \r\n    forms.forEach((item) => {   // для каждой формы запускаем функцию postData и передаем в нее как аргумент форму\r\n      bindPostData(item);\r\n    });\r\n   \r\n    const showThanksModal = (message) => {                                    // сюда передаем как аргумент сообщение пользователю из объекта message\r\n      const thanksModal = document.createElement(\"div\");                      // создаем новую начинку модального окна для сообщения пользователю\r\n      thanksModal.classList.add(\"modal__message\");           \r\n      thanksModal.innerHTML = `\r\n      <div class=\"modal__dialog\">\r\n        <div class=\"modal__content\">\r\n          <div class=\"modal__close\" data-close>×\r\n          </div>\r\n          <div class=\"modal__title\">${message}</div>\r\n        </div>\r\n      <div>\r\n      `; \r\n      document.querySelector(\".page\").append(thanksModal);            // добавляем в модальное окно новое наполнение\r\n      setTimeout(() => {                                               // через определенное время удаляем сообщение пользователю и возвращаем обратно возможность вызвать и отправить форму\r\n        thanksModal.remove();\r\n      }, 4000)\r\n      const modalMessage = document.querySelector(\".modal__message\");\r\n      const modalClose = modalMessage.querySelector(\".modal__close\");\r\n      const closeThanksModal = () => {\r\n        thanksModal.remove();\r\n      }\r\n      modalClose.addEventListener(\"click\", closeThanksModal);\r\n    }      \r\n  \r\n    fetch(\"db.json\")\r\n      .then(data => data.json())\r\n      .then(result => console.log(result))\r\n}\r\nmodule.exports = server;","// SLIDER\r\n\r\nconst slider= () => {\r\n // SLIDER VARIANT 1  (скрытие карточек)\r\n\r\n  /*const slides = document.querySelectorAll(\".offer__slide\");\r\n  const previousSlideButton = document.querySelector(\".offer__slider-prev\");\r\n  const nextSlideButton = document.querySelector(\".offer__slider-next\");\r\n  const total = document.querySelector(\"#total\");\r\n  const current = document.querySelector(\"#current\");\r\n  let currentSlide = 1;                           \r\n\r\n  const showCurrentSlideNumber = () => {                       // устанавливаем значение конкретного слайда\r\n    if (slides.length < 10) {\r\n      current.textContent = `0${currentSlide}`;\r\n    } else {\r\n      current.textContent = currentSlide;\r\n    }\r\n  }\r\n\r\n  const showTotalSlidesQuantity = () => {                       // устанавливаем значение общего количества слайдов\r\n    if (slides.length < 10) {\r\n      total.textContent = `0${slides.length}`;\r\n    } else {\r\n      total.textContent = slides.length;\r\n    }\r\n  }\r\n  showTotalSlidesQuantity();\r\n\r\n  const showSlides = (number) => {            // функция принимает n куда будет приходит номер текущего слайда\r\n    if (number > slides.length) {\r\n      currentSlide = 1;                      // если n больше количества слайдов, то идет возврат на первый слайд\r\n    }\r\n    if (number < 1) {\r\n      currentSlide = slides.length;          // если n меньше количества слайдов, то идет возврат на последний слайд\r\n    }\r\n\r\n    slides.forEach((item) => {               // скрываем все слайды\r\n      item.style.display = \"none\"\r\n    })\r\n\r\n    slides[currentSlide - 1].style.display = \"block\"     // показываем только первый, так как массив начинается с 0, то указываем - 1, так как currentSlide = 1;\r\n    showCurrentSlideNumber()                                   // запускаем функции показа номера конкретного слайда\r\n  }\r\n  showSlides(currentSlide);\r\n  \r\n\r\n  const changeSlides = (number) => {\r\n    showSlides(currentSlide = currentSlide + number);\r\n  }\r\n\r\n  previousSlideButton.addEventListener(\"click\", () => {\r\n    changeSlides(-1);\r\n  })\r\n\r\n  nextSlideButton.addEventListener(\"click\", () => {\r\n    changeSlides(+1);\r\n  })*/\r\n\r\n  // SLIDER VARIANT 2 (проллистывание карточек)\r\n    \r\n  const slides = document.querySelectorAll(\".offer__slide\");\r\n  const slider = document.querySelector(\".offer__slider\")\r\n  const previousSlideButton = document.querySelector(\".offer__slider-prev\");\r\n  const nextSlideButton = document.querySelector(\".offer__slider-next\");\r\n  const total = document.querySelector(\"#total\");\r\n  const current = document.querySelector(\"#current\");\r\n  const slidesWrapper = document.querySelector(\".offer__slider-wrapper\");\r\n  const slidesInner = document.querySelector(\".offer__slider-inner\");\r\n  const width = window.getComputedStyle(slidesWrapper).width;                               // ширина блока где находятся слайдеры\r\n  let currentSlide = 1; \r\n  let offset = 0;                                                  // на какое расстояние мы смещаемся, отсчет от 0   \r\n\r\n  const showTotalSlidesQuantity = () => {                       // устанавливаем значение общего количества слайдов\r\n    if (slides.length < 10) {\r\n      total.textContent = `0${slides.length}`;\r\n      current.textContent = `0${currentSlide}`;\r\n    } else {\r\n      total.textContent = slides.length;\r\n      current.textContent = currentSlide;\r\n    }\r\n  }\r\n  showTotalSlidesQuantity();\r\n\r\n  slidesInner.style.width = 100 * slides.length + \"%\";             // задаем внутренней обложке общую ширину (от количества всех слайдов)\r\n  slidesInner.style.display = \"flex\";                              \r\n  slidesInner.style.transition = \"0.5s all\";                       // плавное смещение всех слайдов\r\n  slidesWrapper.style.overflow = \"hidden\";\r\n  \r\n  slides.forEach((slide) => {\r\n    slide.style.width = width;                                     // каждому слайду устанавливаем ширину равную ширине обертки, все слайды будут одинаковой ширины и внутри обертки\r\n  })\r\n\r\n  slider.style.position = \"relative\";                            \r\n\r\n  const dots = document.createElement(\"ol\");                     // создаем список для кнопок переключения слайдов\r\n  const dotsArray = [];                                          // создаем пустой массив\r\n  dots.classList.add(\"carousel-indicators\");\r\n  slider.append(dots);\r\n\r\n  for (let i = 0; i < slides.length; i++) {                       // создаем кнопки переключения слайдов в количестве совпадающим с количеством слайдов\r\n     const dot = document.createElement(\"li\");\r\n     dot.setAttribute(\"data-slide-to\", i + 1);                    // пронумеровываем каждую кнопку\r\n     dot.classList.add(\"dot\")\r\n     if (i === 0) {\r\n       dot.style.opacity = 1;                                     // задаем активную кнопку через JS (без CSS)\r\n     }\r\n     dots.append(dot)\r\n     dotsArray.push(dot);                                         // помещаем в массив наши точки\r\n  };\r\n \r\n  const deleteLetters = (string) => {                    // функция для замены значения width на числовое с помощью + и далее исключение \"px\" через replace\r\n     return +string.replace(/\\D/g, \"\");\r\n  }\r\n\r\n  nextSlideButton.addEventListener(\"click\", () => {\r\n    if (offset === deleteLetters(width) * (slides.length - 1)) {                 // если отступ будет равен ширине всех слайдов, то возвращаем отступ к базовому значению, также width превращаем в число унарным + и заменяем \"px\" через ругулярное выражение\r\n      offset = 0;\r\n    }  else {\r\n      offset = offset + deleteLetters(width);                       // в противоположном случае смещаем на ширину одного слайда (+width.replace(/\\D/g, \"\"))\r\n    }                                                                                // ширина всех слайдов +width.replace(/\\D/g, \"\") * (slides.length - 1)\r\n    slidesInner.style.transform = `translateX(-${offset}px)`                         // передвигаем элемент по оси X влево при клике\r\n\r\n    if (currentSlide === slides.length) {                                   // если нумерация слайдов равна количеству слайдов, то возвращаем значение к базовому\r\n      currentSlide = 1;\r\n    } else {\r\n      currentSlide++;                                       // в ином случае увеличиваем значение на 1\r\n    }\r\n\r\n    if (slides.length < 10) {\r\n      current.textContent =  `0${currentSlide}`;\r\n    } else {\r\n      current.textContent =  currentSlide;\r\n    }\r\n    dotsArray.forEach((dot) => {                    // перебираем массив точек и присваиваем значение прозрачности при клике\r\n      dot.style.opacity = \"0.5\"\r\n    });\r\n    dotsArray[currentSlide-1].style.opacity = \"1\";        // так как массив начинается с 0, то указываем - 1, так как currentSlide = 1;\r\n  })\r\n\r\n  previousSlideButton.addEventListener(\"click\", () => {                               \r\n    if (offset === 0) {                                                            // если мы на первом слайде, то переносимся на последний       \r\n      offset = deleteLetters(width) * (slides.length - 1)\r\n    }  else {\r\n      offset = offset - deleteLetters(width);                      \r\n    }                                           \r\n    slidesInner.style.transform = `translateX(-${offset}px)`                 // передвигаем элемент по оси X вправо при клике     \r\n    \r\n    if (currentSlide === 1) {                                  // если нумерация слайдов равна 1, то возвращаем значение к значению последнего слайда\r\n      currentSlide = slides.length; \r\n  } else {\r\n      currentSlide--;                                           // в ином случае уменьшаем значение на 1\r\n  }\r\n\r\n  if (slides.length < 10) {\r\n      current.textContent =  `0${currentSlide}`;\r\n  } else {\r\n    current.textContent = currentSlide;\r\n  }\r\n  dotsArray.forEach((dot) => {\r\n    dot.style.opacity = \"0.5\"\r\n  });\r\n  dotsArray[currentSlide-1].style.opacity = \"1\";\r\n });\r\n\r\n\r\n dotsArray.forEach((dot) => {\r\n  dot.addEventListener('click', (evt) => {\r\n      const slideTo = evt.target.getAttribute('data-slide-to');  // находим все кнопки по атрибуту, который присвоили ранее\r\n\r\n      currentSlide = slideTo;                                         \r\n      offset = deleteLetters(width) * (slideTo - 1);\r\n\r\n      slidesInner.style.transform = `translateX(-${offset}px)`;\r\n\r\n      if (slides.length < 10) {\r\n          current.textContent =  `0${currentSlide}`;\r\n      } else {\r\n          current.textContent =  currentSlide;\r\n      }\r\n\r\n      dotsArray.forEach((dot) => {\r\n        dot.style.opacity = \"0.5\"\r\n      });\r\n      dotsArray[currentSlide-1].style.opacity = \"1\";\r\n    });\r\n  });\r\n\r\n}\r\nmodule.exports = slider;","// TABS\r\n\r\nconst tabs = () => {\r\n    const tabsHeader = document.querySelectorAll(\".tabheader__item\");\r\n    const tabsContent = document.querySelectorAll(\".tabcontent\");\r\n    const tabsHeaderParent = document.querySelector(\".tabheader__items\");\r\n  \r\n    const hideTabContent = () => {\r\n      tabsContent.forEach((item) => {\r\n        item.classList.add(\"hidden\");\r\n        item.classList.remove(\"show\", \"fade\");\r\n      });\r\n      tabsHeader.forEach((item) => {\r\n        item.classList.remove(\"tabheader__item--active\");\r\n      });\r\n    };\r\n  \r\n    const showTabContent = (i = 0) => {       // i в данном случае это первый элемент массива\r\n      tabsContent[i].classList.add(\"show\", \"fade\");\r\n      tabsContent[i].classList.remove(\"hidden\");\r\n      tabsHeader[i].classList.add(\"tabheader__item--active\");\r\n    };\r\n  \r\n    hideTabContent();\r\n    showTabContent();\r\n  \r\n    tabsHeaderParent.addEventListener(\"click\", (evt) => {\r\n      const target = evt.target;\r\n      if (target && target.classList.contains(\"tabheader__item\")) {\r\n          tabsHeader.forEach((item, i) => {      // i это номер элемента, который совпал\r\n          if (target === item) {\r\n              hideTabContent();\r\n              showTabContent(i);       \r\n          }\r\n        });\r\n      }\r\n     });\r\n}\r\n\r\nmodule.exports = tabs;","// TIMER\r\n\r\nconst timer = () => {\r\n   const deadline = '2021-07-31';   // конечная дата\r\n\r\n   const getRemainingTime = (endtime) => {\r\n       const t = Date.parse(endtime) - Date.parse(new Date()); // конечная дата минус текущая дата\r\n       const days = Math.floor( (t/(1000*60*60*24)) );  \r\n       const seconds = Math.floor( (t/1000) % 60 );\r\n       const minutes = Math.floor( (t/1000/60) % 60 );\r\n       const hours = Math.floor( (t/(1000*60*60) % 24) );\r\n   \r\n       return {\r\n           'total': t,\r\n           'days': days,\r\n           'hours': hours,\r\n           'minutes': minutes,\r\n           'seconds': seconds\r\n       };\r\n   };\r\n   \r\n   const getZero = (num) => {  // проверяем число и добавляем 0, если меньше 10\r\n     if (num >= 0 && num < 10) {\r\n       return `0${num}`;\r\n     } else {\r\n         return num;\r\n     }\r\n   };\r\n   \r\n   const setClock = (selector, endtime) => {    // сюда передаем два аргумента,в том числе конучную дату\r\n   \r\n       const timer = document.querySelector(selector);\r\n       const days = timer.querySelector(\"#days\");  // выбираем по id раздел\r\n       const  hours = timer.querySelector('#hours'); // выбираем по id раздел\r\n       const  minutes = timer.querySelector('#minutes'); // выбираем по id раздел\r\n       const  seconds = timer.querySelector('#seconds'); // выбираем по id раздел\r\n       timeInterval = setInterval(updateClock, 1000);  // функция обновления значения каждую секунду\r\n       updateClock();\r\n       function updateClock()  {\r\n           const t = getRemainingTime(endtime);\r\n           days.innerHTML = getZero(t.days);\r\n           hours.innerHTML = getZero(t.hours);\r\n           minutes.innerHTML = getZero(t.minutes);\r\n           seconds.innerHTML = getZero(t.seconds);\r\n   \r\n           if (t.total <= 0) {\r\n               clearInterval(timeInterval);\r\n           }\r\n        }\r\n    };\r\n   \r\n   setClock('.timer', deadline);\r\n}\r\n\r\nmodule.exports = timer;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\r\nwindow.addEventListener(\"DOMContentLoaded\", () => {\r\n    const tabs = require('./modules/calculator'),\r\n        modal = require('./modules/card'),\r\n        timer = require('./modules/modal'),\r\n        card = require('./modules/server'),\r\n        calculator = require('./modules/slider'),\r\n        server = require('./modules/tabs'),\r\n        slider = require('./modules/timer');\r\n    \r\n    tabs();\r\n    modal();\r\n    timer();\r\n    card();\r\n    calculator();\r\n    server();\r\n    slider();\r\n});\r\n"],"names":[],"sourceRoot":""}